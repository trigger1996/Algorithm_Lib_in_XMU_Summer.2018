function [a,b]=intercross(a,b)			% TSP问题的交换函数，TSP最难的就是交换，因为序列要求有序且不重复，所以直接交换显然是有问题的
										% 比如1 2 3 4 5 6和6 5 4 3 2 1交换
										% 可能变为 1 2 3 3 2 1和6 5 4 4 5 6
										% 这两个序列必然都是错的
L=length(a);
r1=randsrc(1,1,[1:L]);
r2=randsrc(1,1,[1:L]);
if r1~=r2
    a0=a;b0=b;							% 总的交换之前保存一个
    s=min([r1,r2]);
    e=max([r1,r2]);
    for i=s:e
        a1=a;b1=b;						% 每一轮交换之前保存一个
        a(i)=b0(i);						% 单个交换
        b(i)=a0(i);
        x=find(a==a(i));				% 单个交换完看一下，当前序列中，有没有和交换完的重复的
        y=find(b==b(i));
        i1=x(x~=i);						% 必然会find找到自己，但是除了自己，如果还有别的相同的，则用i1记录下来，
        i2=y(y~=i);						% 而且每次只交换一个，所以至多2个相同的，一个是自己，一个是原有的，所以如果只有自己，那么i1为空，同理，i2也是这样
        if ~isempty(i1)					% 如果i1非空
            a(i1)=a1(i);				% 一模一样的数字有两个，一个是刚替换的，一个是原来就有的，那么就取修改那个原来就有的，原来就有的改成前者，即刚替换的之前的数字，这样形成交换
        end
        if ~isempty(i2)
            b(i2)=b1(i);
        end
    end
end