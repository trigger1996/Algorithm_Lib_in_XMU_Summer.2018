%%
% 选择最大概率的路线走---基于蚁群算法的航迹规划matlab程序
% http://blog.sciencenet.cn/blog-748007-706566.html


%%
%蚁群算法  主要适用于航迹规划，主体思想来源于胡中华博士论文 基于智能优化算法的无人机航迹规划若干关键技术研究
%%%程序编写者  西北工业大学自动化学院    Email： yincwxa2013@mail.nwpu.edu.cn
%选择最大概率的路线走
%%  All rights reserved

%  输入参数列表
% 
%  Tau      初始信息素矩阵（认为前面的觅食活动中有残留的信息素）
%  NN        迭代次数（指蚂蚁出动多少波）
%  MM        蚂蚁个数（每一波蚂蚁有多少个）
%  X0        起始点（最短路径的起始点）
%  Y0        终止点（最短路径的目的点）
%  Alpha    表征信息素重要程度的参数
%  Beta     表征启发式因子重要程度的参数
%  rou      信息素蒸发系数
%  Q        信息素增加强度系数
%  x1       规划区域左下角坐标（二维坐标） 
%  x2       规划区域右下角坐标（二维坐标） 
%  x3       规划区域左上角坐标（二维坐标） 
%  x4       规划区域右上角坐标（二维坐标） 
%  N1       栅格法划分二维空间，每个小网格的边长
%  N2       节点数个数
%  KR       雷达威胁点个数KR= 
%  KM       导弹威胁点个数KM= 
%  KA       高炮威胁点个数KA= 
%  KC       大气威胁点个数KC= 
%  W        雷达、导弹、高炮、大气、耗油威胁的权重构成的权重向量
%  输出参数列表
%  ROUTES   每一代的每一只蚂蚁的爬行路线
%  PL       每一代的每一只蚂蚁的爬行路线长度
%  Tau      输出动态修正过的信息素

 

clear
clc
%X0=input('输入飞行器起点坐标（二维坐标）X0=')

%Y0=input('输入飞行器目标点坐标（二维坐标）Y0=')
%NN=input('输入迭代次数NN=')
%MM=input('输入蚂蚁数MM=')

%x1=input('输入规划区域左下角坐标（二维坐标）')
%x2=input('输入规划区域右下角坐标（二维坐标）')
%x3=input('输入规划区域左上角坐标（二维坐标）')
%x4=input('输入规划区域右上角坐标（二维坐标）')% x1~x4主要是确定规划区域，由坐标来限制区域
%N1=input('输入网格大小为')%栅格法划分二维空间，每个小网格的边长，此处是正方形网格

X0= [10  20]
Y0= [42 50]
NN= 10
MM= 40
x1= [10 20]
x2= [60  20]
x3= [10  70]
x4= [60 70]
N1=2


h1=(x4(1)-x1(1))/N1   ;%网格列数
v1=(x4(2)-x1(2))/N1;%网格行数
N2=h1*v1;%计算节点数个数，即网格划分后的节点个数
%%%%%%%%%%%%%%%%%%%%%%%%%%%对区域内网格划分后 确定节点坐标 并储存
t=1;
for i=1:h1
   for j=1:v1
       tempx=x1(1)+(i-1)*N1; %%对区域栅格化后第（i,j）位置节点的横坐标
       tempy=x1(2)+(j-1)*N1; %%对对区域栅格化后第（i,j）位置节点的纵坐标
       P(t,:)=[tempx,tempy];  %%对对区域栅格化后第（i,j）位置节点的坐标存储，作为第t个节点的坐标，排列顺序是从下往上，从左到右排列
       t=t+1;
   end
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%栅格化并存储节点坐标结束%%%%%%%%%%%

 

%%%%%%%%%%%%%%%%  开始存储各种威胁点的坐标%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%KR=input('输入雷达威胁点个数KR=')
%KM=input('输入导弹威胁点个数KM=')
%KA=input('输入高炮威胁点个数KA=')
%KC=input('输入大气威胁点个数KC=')

KR= 4
KM= 4
KA= 3
KC= 2


%t=1;
%for i=1:KR
%    P_KR(t,:)=input('输入雷达威胁点的（按顺序输入二维坐标）')  %%对对区域栅格化后第（i,j）位置节点的坐标存储，作为第t个节点的坐标，排列顺序是从下往上，从左到右排列
%     t=t+1;
%    end

%t=1;
%for i=1:KM
%     P_KM(t,:)=input('输入导弹威胁点的（按顺序输入二维坐标）')  %%对对区域栅格化后第（i,j）位置节点的坐标存储，作为第t个节点的坐标，排列顺序是从下往上，从左到右排列
%     t=t+1;
%end
% t=1;
%for i=1:KA
%     P_KA(t,:)=input('输入高炮威胁点的（按顺序输入二维坐标）')  %%对对区域栅格化后第（i,j）位置节点的坐标存储，作为第t个节点的坐标，排列顺序是从下往上，从左到右排列
%     t=t+1;
%end   
% t=1;
%for i=1:KC
%     P_KC(t,:)=input('输入大气威胁点的（按顺序输入二维坐标）')  %%对对区域栅格化后第（i,j）位置节点的坐标存储，作为第t个节点的坐标，排列顺序是从下往上，从左到右排列
%    t=t+1;
%end  

P_KR=[26  55
   52  45
   35  26
   51.5 31]

P_KM=[17  22 
24  35 
30  62 
40  38]

P_KA=[10 30
   26 22
   14  46]
P_KC=[16  40
   24  48]

 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%威胁点坐标输入结束%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%开始设计启发因子%%%%%%%%%%%%%%%%%%%


%W=input('输入由雷达、导弹、高炮、大气、耗油威胁的权重构成的权重向量（注意顺序）W=')
W=[0.3 0.2  0.2 0.2 0.1]

for i=1:N2
   %%%雷达威胁总和
   for j=1:KR
       R_ybs(i,j)=1/(((P(i,1)- P_KR(j,1))^2+(P(i,2)- P_KR(j,2))^2)^2);
   end
   ZR(i)=sum(R_ybs(i,:));
   
   %%%导弹威胁总和
   for j=1:KM
       M_ybs(i,j)=1/(((P(i,1)- P_KM(j,1))^2+(P(i,2)- P_KM(j,2))^2)^(1/2));
   end
     ZM(i)=sum(M_ybs(i,:));
     %%%高炮威胁总和
   for j=1:KA
       A_ybs(i,j)=1/(((P(i,1)- P_KA(j,1))^2+(P(i,2)- P_KA(j,2))^2)^(1/2));
   end
     ZA(i)=sum(A_ybs(i,:));
     
      %%%大气威胁总和
   for j=1:KC
       C_ybs(i,j)=1/(((P(i,1)- P_KC(j,1))^2+(P(i,2)- P_KC(j,2))^2)^(1/2));
   end
     ZC(i)=sum(C_ybs(i,:));
   
       %%%油耗威胁因为涉及到最终的航迹轨迹节点个数，不便于计算，在此程序处理中忽略
       
  Eta(i)=1/(W*[ZR(i)  ZM(i)  ZA(i)   ZC(i)  0]');%计算出所有代价加权和之后的倒数作为第i个节点的启发因子
  
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

ROUTES=cell(NN,MM);%用细胞结构存储每一代的每一只蚂蚁的爬行路线
PL=zeros(NN,MM);%用矩阵存储每一代的每一只蚂蚁的爬行路线长度
Tau=ones(N2,N2).*100;   %初始信息素浓度 任选一个常数，本处选择3
%Alpha=input('输入信息素重要程度Alpha=')
%Beta=input('输入启发因子重要程度Beta=')
%rou=input('输入信息素挥发程度rou=')
%Q=input('输入信息素增加强度系数Q=')
%C0=input('输入单位耗油量C0=')

Alpha=1 
Beta= 0.25
rou= 0.6
gama=10
Q= 10
C0=1

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%   计算导引因子%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

for i=1:N2
   lamd(i)=1/sqrt( (P(i,1)-Y0(1))^2+(P(i,2)-Y0(2))^2 )
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 

 


%%%%%%%%%%%%%%%%%%%%%%%%%下面开始迭代计算
for ik=1:NN  %(迭代ＮＮ次)
   
   for m=1:MM
    %%     第一步：状态初始化
       tt=round((X0(1)-x1(1))/N1)+1+round((X0(2)-x1(2))/N1)*h1;% 根据起点坐标得到节点数，采用四舍五入的方法将起点归并到相应的节点处
       tt2=round((Y0(1)-x1(1))/N1)+1+round((Y0(2)-x1(2))/N1)*h1;% 根据目标坐标得到节点数，采用四舍五入的方法将起点归并到相应的节点处
       Current=tt;       ;%当前节点初始化为起始点,一般默认起点在第一个节点，故此处可以设Current=1
       Path=tt;%爬行路线初始化
       PLkm=0;%爬行路线长度初始化
       TABUkm=ones(1,N2);%禁忌表初始化
       TABUkm(Current)=0;%已经在初始点了，因此要排除
       
       %第二步：下一步可以前往的节点 
         Len_LJD=3;  % 可以走的节点个数    从起点开始朝下走，有三个方向可以走，分别是 节点2  节点1+v1 节点 1+v1+1
         LJD=[2,1+h1, 1+h1+1];% 可以走的节点的集合
         
         
         %下面开始循环   觅食停止条件：蚂蚁未遇到食物或者陷入死胡同
         
       while (Current~=tt2)&(Len_LJD>=1)
           
           
%%         第三步：转轮赌法选择下一步怎么走
           PP=zeros(1,Len_LJD);   
           for i=1:Len_LJD
               PP(i)=(Tau(Current,LJD(i))^Alpha)*(Eta(LJD(i))^Beta)*((lamd(LJD(i)))^gama);%%%在此处加入了导引因子
           end
            %PP
           PP=PP./(sum(PP));%建立概率分布
           % Pcum=cumsum(PP);
           % Select=find(Pcum>=rand);
          %  if isempty(Select)   %判别是否为空
           %     to_visit=LJD(1);
           % else
           %     to_visit=LJD(Select(1));%选择随机产生的第一个下标所对应的节点
            %end
           
            Select=find(PP>=max(PP));%选择概率较大的下标 一条路线走
          to_visit=LJD(Select(1));%选择概率较大的下标所对应的节点
           
%%         第四步：状态更新和记录
           Path=[Path,to_visit];%路径增加
           
           CtoVLenght=sqrt((P(Current,1)-P(to_visit,1))^2+(P(Current,2)-P(to_visit,2))^2);%计算当前点到下一个节点之间的距离
           
           PLkm=PLkm+CtoVLenght;%路径长度增加
           Current=to_visit;%蚂蚁移到下一个节点
           
           TABUkm(Current)=0;%已访问过的节点从禁忌表中删除
          
           %%%%%%%%%%下面寻找新的节点，在其附近的九宫图相邻点构成的节点集合
           ttt=[Current-h1-1,  Current-h1,  Current-h1+1, Current-1,   Current+1,  Current+h1-1,  Current+h1,  Current+h1+1];%根据九宫图确定可以走的路径
           
           for kkkk=1:N2
               if sum(ttt==kkkk)>0 %%%%% 只搜索循环中ttt中有的节点进行判别
                   if TABUkm(kkkk)==0   %%% 查找到环中ttt中有的节点是否走过  如果走过则将该节点结合ttt中的数值设为0便于后面排除
                       ttt(find(ttt==kkkk))=0 ;
                   end
               end
           end
           tsite=find(ttt>0&ttt<=N2);         %排除九宫图构造中不存在的点和走过点的下表
           LJD=ttt(tsite);   %查找到当前可以走的点        
           Len_LJD=length(LJD);%可选节点的个数
       end
       %第五步：记下每一代每一只蚂蚁的觅食路线和路线长度
       ROUTES{ik,m}=Path ;
       if Path(end)==tt2
           PL(ik,m)=PLkm;
       else
           PL(ik,m)=inf;
       end
   end
%%%%%%**********&&&&&  至此 所有一群蚂蚁全部走一次  完成一次迭代            
     %% 第六步：更新信息素
   
     temp_sit=find(PL(ik,:)==min(PL(ik,:))); %获取路径最短的一个蚂蚁走的路
     ROUT=ROUTES{ik,temp_sit(1)} %获取路径最短蚂蚁经过的路径
     Best_t=0;
     for j=1:length(ROUT)
         Best_t=Best_t+W(1)*ZR(ROUT(j))+W(2)*ZM(ROUT(j))+W(3)*ZA(ROUT(j))+W(4)*ZC(ROUT(j));%计算出最优路径下是雷达、导弹、高炮、大气威胁的综合值
     end
     Best_t=Best_t+C0*min(PL(ik,:));%计算出最优路径下是雷达、导弹、高炮、大气威胁、耗油量的综合值即为最优路径的代价
     Delta_Tau=zeros(N2,N2);    %更新量初始化
     for j1=1:length(ROUT)
         for j2=1:length(ROUT)
             Delta_Tau(ROUT(j1),ROUT(j2))=Q/Best_t;      %对最优路径上的蚂蚁通过的结点进行信息素更新 其他的全部为0
         end
     end
     Tau= rou.*Tau+(1-rou).*Delta_Tau;%信息素挥发一部分，新增加一部分
end

 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%下面输出最短距离 和最短距离对应的路径%%%%%%%%%%%%%
   Temp_SIT=find(PL==min(min(PL)));
   row= mod(Temp_SIT(1),NN);%  mod  是取余数
   if row==0
       row=NN;
   end
   lie=ceil(Temp_SIT(1)/NN);% ceil（X）向上取整
 
   MIN_Path_Length=PL(row,lie)    % 输出最短路径长度
    MIN_Path=ROUTES{row,lie}       % 输出最短路径
   
 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%                                         %%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%                                         %%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%     迭代完成  下面是作图                 %%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%                                         %%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%                                         %%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


plotif=1;%是否绘图的控制参数
if plotif==1
   %绘收敛曲线
   meanPL=zeros(1,NN);
   minPL=zeros(1,NN);
   for i=1:NN
       PLK=PL(i,:);
       Nonzero=find(PLK)
       PLKPLK=PLK(Nonzero);
       meanPL(i)=mean(PLKPLK);
       minPL(i)=min(PLKPLK);
   end
   figure(1)
   plot(minPL,'r*');
   hold on
   plot(meanPL);
   grid on
   title('收敛曲线（平均路径长度和最小路径长度）');
   xlabel('迭代次数');
   ylabel('路径长度');
   figure(2)
   for  i=1:NN
       plot(PL(i,:));
       hold on
   end
   
   figure(3)
       hold on
 plot(P_KR(:,1),P_KR(:,2),'b*')
 plot(P_KM(:,1),P_KM(:,2),'g^')
 plot(P_KA(:,1),P_KA(:,2),'+')
 plot(P_KC(:,1),P_KC(:,2),'ro')
  
 Temp_ROUT=ROUTES{NN,MM};
 
 plot(P(Temp_ROUT,1),P(Temp_ROUT,2),'x')
   
   
   
end