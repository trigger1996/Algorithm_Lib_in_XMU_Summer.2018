clear;
clc;
clear all;

G=[0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0; 
   0 1 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0; 
   0 1 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0; 
   0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0; 
   0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0; 
   0 1 1 1 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0; 
   0 1 1 1 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0;
   0 1 1 1 0 0 1 1 1 0 1 1 1 1 0 0 0 0 0 0; 
   0 1 1 1 0 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0; 
   0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0; 
   0 0 0 0 0 0 0 1 1 1 1 1 1 1 0 0 0 0 0 0; 
   0 0 0 0 0 0 0 1 1 1 1 1 1 1 0 0 0 0 0 0; 
   0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 1 1 1 1 0; 
   0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 1 1 1 1 0; 
   1 1 1 1 0 0 0 0 0 0 0 1 1 1 0 1 1 1 1 0; 
   1 1 1 1 0 0 1 1 1 1 1 1 0 0 0 0 0 0 0 0; 
   0 0 0 0 0 0 1 1 1 1 1 1 0 0 0 0 0 1 1 0; 
   0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 1 1 0; 
   0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0; 
   0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0;];

G = ~G;

L = size(G, 1);

% 二维卷积效果不好
%Weight_Mat = [ 10, 5,   2;
%			   5,  1,   0.5;
%			   2,  0.5, 0.1; ];

%G_conv2 = conv2(G, Weight_Mat);

startGrid = [ 0, 0 ];
endGrid   = [ L, L ];


G_Grad = zeros(L);
for y = 1 : L
	for x = 1 : L
		if G(y, x) == 0
			G_Grad(y, x) = 0;
		else
			dx = x - endGrid(1);
			dy = y - endGrid(2);
			G_Grad(y, x) = sqrt(dx * dx + dy * dy);
		end
	end
end

% 计算邻接矩阵
l=size(G,1); 
D=zeros(l*l,l*l);													% 邻接矩阵需要考虑点与每个点之间的联系，所以必须是原坐标值的长*宽
for i=1:l
	for j=1:l
		if G_Grad(i,j)~=0												% 当前点可通行才进行计算
			for m=1:l
				for n=1:l											% 遍历所有点，查找临近点
					if G_Grad(m,n)~=0									% 目标点可通行才进行计算
						im=abs(i-m);jn=abs(j-n);					% 计算dx和dy
						if im+jn==1||(im==1&&jn==1)					% x、y差值为1或者x、y差值均为1才是邻近的
							%D((i-1)*l+j,(m-1)*l+n)=(im+jn)^0.5;
							D((i-1)*l+j,(m-1)*l+n) = (G_Grad(i,j) + G_Grad(m,n)) / 2.;
						end
					end
				end
			end
		end
	end
end
		   
